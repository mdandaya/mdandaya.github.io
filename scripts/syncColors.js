// Run with `node scripts/syncColors.js`
// Syncs colors in styles/colors.css with
// theme/colors.ts and tailwind.config.ts.theme.extend.colors
const fs = require("fs");
const path = require("path");

// Function to extract CSS variables from a file
const extractCssVariables = (cssFilePath) => {
  const cssContent = fs.readFileSync(cssFilePath, "utf-8");
  const variableRegex = /--([\w-]+):\s*([^;]+);/g;

  const variables = {};
  let match;

  // Extract all matches
  while ((match = variableRegex.exec(cssContent)) !== null) {
    const variableName = match[1]; // e.g., primary
    const variableValue = match[2].trim(); // e.g., #0070f3
    variables[variableName] = variableValue;
  }

  return variables;
};

// Function to resolve "var(--something)" references to actual values
const resolveReferences = (variables) => {
  const resolvedVariables = { ...variables };

  Object.keys(resolvedVariables).forEach((key) => {
    let value = resolvedVariables[key];

    // Resolve references recursively if value contains "var(--...)"
    const referenceRegex = /var\(--([\w-]+)\)/g;
    let match;

    while ((match = referenceRegex.exec(value)) !== null) {
      const referencedKey = match[1];

      // Replace "var(--key)" with the actual value if it exists
      if (variables[referencedKey]) {
        value = value.replace(match[0], variables[referencedKey]);
      }
    }

    resolvedVariables[key] = value;
  });

  return resolvedVariables;
};

// Function to convert CSS variable names to camelCase
const toCamelCase = (str) => {
  return str.replace(/-([a-z])/g, (_, char) => char.toUpperCase());
};

// Function to update Tailwind configuration
const updateTailwindConfig = (colors) => {
  const tailwindConfigPath = path.resolve(__dirname, "../tailwind.config.ts");

  if (!fs.existsSync(tailwindConfigPath)) {
    console.error(`Tailwind config file not found: ${tailwindConfigPath}`);
    process.exit(1);
  }

  const tailwindConfigContent = fs.readFileSync(tailwindConfigPath, "utf-8");

  // Convert colors object to a formatted string without quotes on keys
  const colorsArray = JSON.stringify(colors, null, 2)
    .replace(/\"([^(\")"]+)\":/g, "$1:") // Remove quotes from keys
    .split("\n");

  // Determine the index of the last color property
  const lastColorIndex = colorsArray.length - 1; // Last line is closing '}'

  // Initialize a new array to hold the formatted lines
  const formattedColors = [];

  colorsArray.forEach((line, index) => {
    if (index === 0) {
      // First line (opening '{') remains unindented
      formattedColors.push(line);
    } else if (index === 1) {
      // Insert the comment after the opening '{' with 8 spaces indentation
      formattedColors.push(`        // Auto generated by scripts/sync-colors.js`);
      // Then add the first color property with 6 spaces indentation
      formattedColors.push(`      ${line}`);
    } else if (index === lastColorIndex) {
      // Last line (closing '}') is indented by 6 spaces
      formattedColors.push(`      ${line}`);
    } else if (index === lastColorIndex - 1) {
      // Second last line: last color property, ensure it has a trailing comma
      // Check if line already ends with a comma
      if (!line.trim().endsWith(",")) {
        formattedColors.push(`      ${line},`);
      } else {
        formattedColors.push(`      ${line}`);
      }
    } else {
      // All other lines: indent by 6 spaces
      formattedColors.push(`      ${line}`);
    }
  });

  // Join the formatted lines back into a single string
  const colorsString = formattedColors.join("\n");

  // Regular expression to find the colors section within theme.extend
  const colorsRegex = /(theme:\s*{\s*[^}]*?extend:\s*{\s*[^}]*?colors:\s*){[^}]*}/m;

  // Replace the existing colors section with the new one
  const updatedConfigContent = tailwindConfigContent.replace(colorsRegex, `$1${colorsString}`);

  // Write the updated Tailwind config back to the file
  try {
    fs.writeFileSync(tailwindConfigPath, updatedConfigContent, "utf-8");
    console.log(`Tailwind config updated at: ${tailwindConfigPath}`);
  } catch (error) {
    console.error(`Failed to update Tailwind config: ${error.message}`);
    process.exit(1);
  }
};

// Entry point
const main = () => {
  const cssFilePath = path.resolve(__dirname, "../src/styles/colors.css"); // Path to the CSS file
  const outputTsPath = path.resolve(__dirname, "../src/theme/colors.ts"); // Path to output TypeScript file

  if (!fs.existsSync(cssFilePath)) {
    console.error(`CSS file not found: ${cssFilePath}`);
    process.exit(1);
  }

  const variables = extractCssVariables(cssFilePath);
  const resolvedVariables = resolveReferences(variables);

  // Convert variable names to camelCase
  const camelCasedVariables = {};
  Object.keys(resolvedVariables).forEach((key) => {
    camelCasedVariables[toCamelCase(key)] = resolvedVariables[key];
  });

  const tsContent = `
/**
 * Auto-generated file. Do not edit manually.
 * Generated from styles/colors.css
 */
const colors = ${JSON.stringify(camelCasedVariables, null, 2)};

export default colors;
`;

  // Write the TypeScript file
  try {
    fs.mkdirSync(path.dirname(outputTsPath), { recursive: true });
    fs.writeFileSync(outputTsPath, tsContent.trim(), "utf-8");
    console.log(`TypeScript file generated at: ${outputTsPath}`);
  } catch (error) {
    console.error(`Failed to write TypeScript file: ${error.message}`);
    process.exit(1);
  }

  // Update Tailwind config
  updateTailwindConfig(camelCasedVariables);
};

main();
